<?php
// $Id$

/**
 * @file
 * Integrates with the Sunlight service to
 *  - lookup Congressional Districts when a CiviCRM contact changes.
 *  - provide API to get information about CDs, legislators, contacts, users and how they all
 *    interrelate.
 *
 * @glossary
 *  cd or CD - Congressional District ex. 'NY17'.
 *  district - The numerical portion of a CD ex. 17.
 *    single digit districts shall have no leading zeros.
 *  zone - A region: either 'state' or 'cd'.
 *
 * @todo validate that data manually entered in a CiviCRM CD field fits our format.
 */

/**
 * @category CONSTANTS
 */

// The table in CiviCRM that contains our custom Congressional District fields.
define('CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE', variable_get('cd_sunlight_civicrm_custom_table', ''));

// The name of the field in CiviCRM that contains the CD (custom_N). Should be read-only in the UI.
// Needs to be a Alphanumeric-text.
define('CD_SUNLIGHT_CIVICRM_CD', variable_get('cd_sunlight_civicrm_cd', ''));

// The name of the field in CiviCRM that contains the overridden CD (custom_N).
// Needs to be a Alphanumeric-text.
// If this field contains data it is used instead of CD_SUNLIGHT_CIVICRM_CD.
define('CD_SUNLIGHT_CIVICRM_CD_OVERRIDE', variable_get('cd_sunlight_civicrm_cd_override', ''));

// The name of the field in CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE that contains CD_SUNLIGHT_CIVICRM_CD.
define('CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD', variable_get('cd_sunlight_civicrm_custom_field_cd', ''));

// The name of the field in CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE that contains CD_SUNLIGHT_CIVICRM_CD_OVERRIDE.
define('CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE', variable_get('cd_sunlight_civicrm_custom_field_cd_override', ''));

// The country_id for United States.
define('CD_SUNLIGHT_CIVICRM_US_COUNTRY_ID', 1228);

// The state_province_id for non-US.
define('CD_SUNLIGHT_CIVICRM_NON_US_STATE_PROVINCE_ID', 1099);

/**
 * @category HOOKS
 */

/**
 * Implementation of hook_menu().
 */
function cd_sunlight_menu() {
  $items = array();
  $items['admin/settings/cd_sunlight'] = array(
    'title' => 'CiviCRM Congressional District',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cd_sunlight_settings_form'),
    'access arguments' => array('administer site configuration'),
  );
  $items['admin/settings/cd_sunlight/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cd_sunlight_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => '0',
  );
  $items['admin/settings/cd_sunlight/fields'] = array(
    'title' => 'Fields',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cd_sunlight_settings_fields_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => '2',
  );
  return $items;
}

/**
 * Implementation of hook_cron().
 */
function cd_sunlight_cron() {

  // Only run under low server load.
  list($load) = sys_getloadavg();
  if (is_numeric($load) && $load > CD_SUNLIGHT_CRON_LOAD_LIMIT) {
    watchdog('cd_sunlight', 'System load is higher than '. CD_SUNLIGHT_CRON_LOAD_LIMIT .
      ', cd_sunlight_cron will not be run.', array(), WATCHDOG_WARNING);
    return;
  }

  // Test connection.
  if (!_cd_sunlight_connection_test()) {
    watchdog('cd_sunlight', 'A connection cannot be made to Sunlight,'
      .' cd_sunlight_cron will not be run.', array(), WATCHDOG_ERROR);
    return;
  }

  // Process the queue.
  _cd_sunlight_process_queue();

  // Refresh all info for stored CDs once every 24hrs.
  $last_run = variable_get('cd_sunlight_last_process_new_regions', 0);
  $time = $_SERVER['REQUEST_TIME'];
  $day_ago = ($time - 60 * 60 * 24);
  $has_been_populated = _cd_sunlight_legislators_exist();
  if (!$has_been_populated || $last_run < $day_ago) {
    _cd_sunlight_zone_update_all();
    variable_set('cd_sunlight_last_process_new_regions', $time);
  }

}

/**
 * Implementation of hook_requriements().
 */
function cd_sunlight_requirements($phase) {
  global $db_url;
  $requirements = array();
  if ($phase == 'runtime') {

    // Raise an error if a there is no db_url entry for civicrm.
    if (!is_array($db_url) || !isset($db_url['civicrm'])) {
      $requirements['cd_sunlight_db'] = array(
        'title' => 'CD Sunlight',
        'description' => t('In settings.php $db_url must be an array and you must have an element '.
          'in $db_url for "civicrm"!'),
        'severity' => REQUIREMENT_ERROR,
        'value' => t('settings.php issue'),
      );
    }

    // Raise an error if a the module has not been setup.
    if (
      !variable_get('cd_sunlight_api_key', '') ||
      !variable_get('cd_sunlight_civicrm_cd', '') ||
      !variable_get('cd_sunlight_civicrm_cd_override', '')
    ) {
      $requirements['cd_sunlight_setup'] = array(
        'title' => 'CiviCRM Sunlight Congressional District',
        'description' => t('You have not <a href="!url">configured</a> the module.'
          , array('!configured' => url('/admin/settings/cd_sunlight'))),
        'severity' => REQUIREMENT_ERROR,
        'value' => t('Not configured'),
      );
    }

    // Report the number of records in the lookup queue.
    $count = db_result(db_query('SELECT COUNT(*) FROM {cd_sunlight_cron}'));
    $requirements['cd_sunlight_count'] = array(
      'title' => 'CiviCRM Sunlight Congressional District',
      'value' => t('There are !count contacts in the queue for a CD lookup.',
        array('!count' => $count)),
      'count' => $count,
      'severity' => REQUIREMENT_INFO
    );

    // Report the number of records in the batch geocoding queue.
    if (variable_get('cd_sunlight_geocoding_off', FALSE)) {
      db_set_active('civicrm');
      $count = db_result(db_query('SELECT COUNT(*) FROM civicrm_address
        WHERE geo_code_1 IS NULL
          AND country_id IS NOT NULL
          AND state_province_id IS NOT NULL'));
      db_set_active();
      $requirements['cd_sunlight_geocode_count'] = array(
        'title' => 'CiviCRM Contact GeoCoding',
        'value' => t('There are !count contacts in the queue to be geocoded.',
          array('!count' => $count)),
        'count' => $count,
        'severity' => REQUIREMENT_INFO
      );
    }

    // Report an error if there are no legislators (cron needs to be run).
    if (!_cd_sunlight_legislators_exist()) {
      $requirements['cd_sunlight_legislators_exist'] = array(
        'title' => 'Members of Congress',
        'value' => 'Do not exist',
        'description' => t('Run cron to retrieve members of Congress from Sunlight.'),
        'severity' => REQUIREMENT_ERROR,
      );
    }

  }
  return $requirements;
}

/**
 * Implementation of hook_civicrm_pre().
 *
 * Queue an edited contact for a CD lookup if necessary.
 * We use the pre hook so that we can compare old data with new data and only queue if changed.
 */
function cd_sunlight_civicrm_pre($op, $object_type, $contact_id, &$ref) {

  // These are the object types that we work with.
  $object_types = array('Individual', 'Organization', 'Household', 'Contact_Location');
  if (!in_array($object_type, $object_types)) {
    return TRUE;
  }
  $doing_lookup = FALSE;

  // Check our semaphore.
  if (_cd_sunlight_contact_set_cd_is_running()) {
    return TRUE;
  }

  // Turn geocoding off.  This hook won't fire during CiviCRM's UpdateAddress.php cron script.
  if (variable_get('cd_sunlight_geocoding_off', FALSE)) {
    _cd_sunlight_geocode_set('disable');
  }

  if ($op != 'edit') {
    return TRUE;
  }

  // If the user is on the a profile page we deal with that in hook_post, else queue.
  if (arg(0) == 'user' && arg(2) == 'edit' && arg(3)) {
    // Enable geocoding for profile pages.
    _cd_sunlight_geocode_set('enabled');
    $doing_lookup = TRUE;
  }
  else {

    // Bloody hell!  CiviCRM might pass in an object, or an array, and it may have different depths.
    $_ref = (array)$ref;
    // CiviCRM 2.0-2.2 compatible.
    if (isset($_ref['location'][1]['address'])) {
      foreach ($_ref['location'] as $location) {
        if ($location['address']['is_primary']) {
          $address = $location['address'];
        }
      }
    }
    // CiviCRM 2.0-2.2 compatible.
    elseif (isset($_ref['location']['address'])) {
      $address = $_ref['location']['address'];
    }
    // CiviCRM 3.0+ compatible.
    elseif (isset($_ref['address'])) {
      foreach ($_ref['address'] as $addy) {
        if ($addy['is_primary']) {
          $address = $addy;
        }
      }
    }
    else {
      // Address is not here.
      $backtrace = _cd_sunlight_backtrace();
      watchdog('cd_sunlight', 'Error durring hook_civicrm_pre() This version of CiviCRM might not '.
        'be supported. @backtrace @ref', array('@backtrace' => $backtrace, '@ref' => var_export($_ref)),
        WATCHDOG_ERROR,
        l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
      return TRUE;
    }
    $ref_postal_code = $address['postal_code'];
    $ref_street_address = $address['street_address'];

    // Is this different from the stored contact (i.e. has the address changed)?
    $params = array(
      'contact_id' => $contact_id,
      'return.postal_code' => TRUE,
      'return.street_address' => TRUE,
    );
    $contact = _cd_sunlight_civicrm_contact_get($params);
    if (civicrm_error($contact)) {
      $backtrace = _cd_sunlight_backtrace();
      watchdog('cd_sunlight', 'Error loading contact in cd_lookup_civicrm_pre(). @backtrace @contact',
        array('@backtrace' => $backtrace, '@contact' => var_export($contact, TRUE)), WATCHDOG_ERROR,
        l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
      return TRUE;
    }

    // We only queue if the postal code / address exists and it's changed from the previous value.
    if (!empty($ref_postal_code) && $ref_postal_code != $contact['postal_code'] ||
      !empty($ref_street_address) && $ref_street_address != $contact['street_address']
    ) {
      $doing_lookup = TRUE;
      cd_sunlight_contact_enqueue($contact_id);
    }
  }

  if ($doing_lookup) {
    // CiviCRM doesn't automatically reset the lat/long when an address is edited.
    // This causes issues where if geocoding is disabled, the existing lat/long are now invalid.
    // We'll manually reset the lat/long.  It will be updated when the contact is next geocoded.
    $geo_code_reset = FALSE;
    if (is_array($ref)) {
      // CiviCRM 2.0-2.2 compatible.
      if (!empty($ref['location'][1]['address']['geo_code_1'])) {
        foreach ($ref['location'] as &$location) {
          $location['address']['geo_code_1'] = '';
          $location['address']['geo_code_2'] = '';
        }
        $geo_code_reset = TRUE;
      }
      // CiviCRM 3.0+ compatible.
      elseif (!empty($ref['address'])) {
        foreach ($ref['address'] as &$address) {
          $address['geo_code_1'] = '';
          $address['geo_code_2'] = '';
        }
        $geo_code_reset = TRUE;
      }
    }
    // CiviCRM 2.0-2.2 compatible.
    elseif (is_object($ref) && !empty($ref->location['address']['geo_code_1'])) {
      $ref->location['address']['geo_code_1'] = '';
      $ref->location['address']['geo_code_2'] = '';
      $geo_code_reset = TRUE;
    }
    if (!$geo_code_reset) {
     $backtrace = _cd_sunlight_backtrace();
      watchdog('cd_sunlight', 'Error durring geocode reset.  This version of CiviCRM might not '.
        'be supported. @backtrace @ref', array('@backtrace' => $backtrace, var_export($ref, TRUE)),
        WATCHDOG_ERROR,
        l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
      return TRUE;
    }
  }

  return TRUE;
}

/**
 * Implementation of hook_civicrm_post().
 *
 * Lookup the CD immediately if we are on a user-submitted CiviCRM profile.
 * Queue new contacts.
 */
function cd_sunlight_civicrm_post($op, $object_type, $contact_id, $ref) {
  if (_cd_sunlight_contact_set_cd_is_running()) {
    return;
  }

  // These are the object types that we work with.
  $object_types = array('Individual', 'Organization', 'Household', 'Contact_Location');
  if (!in_array($object_type, $object_types)) {
    return;
  }

  if ($op == 'create') {

    // We queue new contacts here and not in hook_pre because they don't have a contact_id in
    // hook_pre.
    cd_sunlight_contact_enqueue($contact_id);
  }
  elseif ($op == 'edit') {

    // For an edited contact, do a lookup if we are on a CiviCRM profile form.
    // We can't use hook_pre for this because any CD data that we store would be
    // overwritten by the profile after hook_pre finishes.
    if (arg(0) == 'user' && arg(2) == 'edit' && arg(3)) {

      // Turn geocoding back off if necessary.  We enabled it during the pre hook.
      _cd_sunlight_geocode_set('disabled');

      // Get the CD.
      $cd = _cd_sunlight_contact_cd_update($contact_id);
      if ($cd === FALSE) {
        drupal_set_message(
          'Unfortunately we were not able to determine your congressional district.', 'error');
      }
    }
  }
}

/**
 * @category FORMS
 */

/**
 * Admin settings form.
 */
function cd_sunlight_settings_form() {
  civicrm_initialize();
  $form = array();
  $form['cd_sunlight_api_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Sunlight API Key'),
    '#description' => t('You can obtain your key from <a href="!url">Sunlight Labs</a>.'
      , array('!url' => url('http://services.sunlightlabs.com/api/'))),
    '#default_value' => variable_get('cd_sunlight_api_key', ''),
    '#required' => TRUE,
  );
  $form['cd_sunlight_cron_load_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Cron server load limit'),
    '#description' => t('Do not run Cron CD lookups if the system load is higher than this value. '
      . 'Only applicable to Linux based servers. '),
    '#default_value' => variable_get('cd_sunlight_cron_load_limit', 2),
  );
  $form['cd_sunlight_geocode'] = array(
    '#type' => 'fieldset',
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#title' => 'Advanced Batch Geocoding',
    '#description' => t('You should <a href="!url_geocode">enable geocoding within CiviCRM</a> '
      . "for more accurate determination of a contact's congressional district (some congressional "
      . 'districts contain more than one zip code).  However geocoding can put a big load on your '
      . 'server if you are ever saving several contacts per second from multiple HTTP requests. '
      . 'Instead CiviCRM Sunlight Congressional District has the ability to override CiviCRM and '
      . 'perform geocoding only in batches during cron and on any CiviCRM profiles used for '
      . '"View/Edit User Account".  To use this feature you first must <a href="!url_setup">setup '
      . ' a user, password and key for CiviCRM Command-line usage</a>. Enter these values below. '
      . '<br />NOTE: 95% of sites will not require or see any benefit from batch geocoding.'
      , array(
        '!url_geocode' => url('civicrm/admin/setting/mapping'),
        '!url_setup' => url('http://wiki.civicrm.org/confluence/display/CRMDOC/Command-line+Script+Configuration'),
      )),
  );
  $form['cd_sunlight_geocode']['cd_sunlight_geocoding_off'] = array(
    '#type' => 'checkbox',
    '#title' => t('Run CiviCRM geocoding only during cron and some CiviCRM profiles'),
    '#default_value' => variable_get('cd_sunlight_geocoding_off', FALSE),
  );
  $form['cd_sunlight_geocode']['cd_sunlight_geocode_key'] = array(
    '#title' => t('CiviCRM command-line script key'),
    '#type' => 'item',
    '#value' => defined('CIVICRM_SITE_KEY') ? 'Is defined' : 'Is not defined',
    '#description' => t('The CiviCRM command-line key. '),
  );
  $form['cd_sunlight_geocode']['cd_sunlight_geocode_crypt'] = array(
    '#title' => t('Crypt libraries'),
    '#type' => 'item',
    '#value' => _cd_sunlight_crypt_enabled() ? 'Available' : 'Not available',
    '#description' => t('The <a href=!url>PHP MCrypt extension</a> is required for storing the '
      . 'username. ', array(
        '!url' => url('http://www.php.net/manual/en/book.mcrypt.php'),
      )),
  );
  $form['cd_sunlight_geocode']['cd_sunlight_geocode_username'] = array(
    '#type' => 'textfield',
    '#title' => t('Username used in CiviCRM geocode script'),
    '#disabled' => !_cd_sunlight_crypt_enabled(),
    '#default_value' => _cd_sunlight_crypt_decrypt(variable_get('cd_sunlight_geocode_username', '')),
    '#attributes' => array('autocomplete' => 'off'),
  );
  $form['cd_sunlight_geocode']['cd_sunlight_geocode_password'] = array(
    '#type' => 'item',
    '#title' => t('Password used in CiviCRM geocode script'),
    '#value' => defined('CD_SUNLIGHT_GEOCODE_PASSWORD') ? 'Is defined' : 'Is not defined',
    '#description' => t('You must define the password in a constant called !const in settings.php',
      array('!const' => 'CD_SUNLIGHT_GEOCODE_PASSWORD')),
    '#attributes' => array('autocomplete' => 'off'),
  );
  $form['cd_sunlight_geocode']['test'] = array(
    '#type' => 'fieldset',
    '#description' => t('You will need to resolve any issues shown here, or in <a href="!url">the '
      . 'logs</a> (PHP timeouts, etc.) before batch geocoding will work. ', array(
        '!url' => url('admin/reports/dblog'),
      )),
  );
  $form['cd_sunlight_geocode']['test']['test'] = array(
    '#type' => 'submit',
    '#value' => t('Test batch geocoding'),
    '#submit' => array('cd_sunlight_contacts_geocode'),
    '#disabled' => !_cd_sunlight_crypt_enabled() ||
      !defined('CIVICRM_SITE_KEY') ||
      !defined('CD_SUNLIGHT_GEOCODE_PASSWORD') ||
      !variable_get('cd_sunlight_geocode_username', ''),
  );

  $form = system_settings_form($form);
  return $form;
}

function cd_sunlight_settings_form_validate($form, &$form_state) {

  // Temporarily replace the existing API key.
  $key_existing = variable_get('cd_sunlight_api_key', '');
  variable_set('cd_sunlight_api_key', $form_state['values']['cd_sunlight_api_key']);

  // Test the new one.
  if (!_cd_sunlight_connection_test()) {
    form_set_error('cd_sunlight_api_key'
      , t('Either the Sunlight key is not valid, or the Sunlight API is down. '
        .'See watchdog for more detailed information.'));
  }
  else {
    drupal_set_message(t('The Sunlight API key works.'));
  }

  // Revert.
  variable_set('cd_sunlight_api_key', $key_existing);

  // Test the geocoding username.
  if ($user_name = $form_state['values']['cd_sunlight_geocode_username']) {
    $message = 'The geocoding user does not exist';
    $user_valid = FALSE;
    $account = user_load(array('name' => $user_name));
    if ($account && $account->uid) {
      $message = 'The geocoding user exists';
      if (user_access('access all custom data', $account)) {
        $message .= ' with correct permissions';
        drupal_set_message($message);
        $user_valid = TRUE;
      }
      else {
        $message .= ' but without correct permissions';
      }
    }
    if (!$user_valid) {
      form_set_error('cd_sunlight_geocode_username', $message);
    }

    // Encrypt the geocoding username.
    if (_cd_sunlight_crypt_enabled()) {
      $user_name_encrypted =
        _cd_sunlight_crypt_encrypt($user_name);
      form_set_value($form['cd_sunlight_geocode']['cd_sunlight_geocode_username'],
        $user_name_encrypted, $form_state);
    }
  }

}

/**
 * Form to choose CiviCRM custom fields that stores data.
 *
 * @return array
 *  FAPI array
 */
function cd_sunlight_settings_fields_form() {

  // Get options.
  db_set_active('civicrm');
  $resource = db_query('SELECT id, custom_group_id, label FROM civicrm_custom_field
    WHERE data_type = "string" ORDER BY custom_group_id, weight');
  db_set_active();
  $fields = array();
  while ($field = db_fetch_array($resource)) {
    $fields[$field['id']] = $field['custom_group_id'] .': '. check_plain($field['label']);
  }

  // Form.
  $form = array(
    '#prefix' => '<div>' . t(
      'CiviCRM Congressional District stores congressional district data for each CiviCRM '
      . 'contact in a set of CiviCRM custom fields.  You create these fields <a href="!url">within '
      . 'CiviCRM</a>. ', array('!url' => url('civicrm/admin/custom/group'))) .'</div>' ,
  );

  $field_cd_sunlight_civicrm_cd = variable_get('cd_sunlight_civicrm_cd', '');
  $field_cd_sunlight_civicrm_cd = explode('_', $field_cd_sunlight_civicrm_cd);
  $field_cd_sunlight_civicrm_cd = array_pop($field_cd_sunlight_civicrm_cd);
  $form['field_cd_sunlight_civicrm_cd'] = array(
    '#type' => 'select',
    '#title' => 'Congressional District Field',
    '#default_value' => check_plain($field_cd_sunlight_civicrm_cd),
    '#options' => $fields,
    '#description' => t('Create one alphanumeric text field (should be searchable and '
      . 'read-only) to store the contact\'s congressional district. '),
    '#required' => TRUE,
  );

  $field_cd_sunlight_civicrm_cd_override = variable_get('cd_sunlight_civicrm_cd_override', '');
  $field_cd_sunlight_civicrm_cd_override = explode('_', $field_cd_sunlight_civicrm_cd_override);
  $field_cd_sunlight_civicrm_cd_override = array_pop($field_cd_sunlight_civicrm_cd_override);
  $form['field_cd_sunlight_civicrm_cd_override'] = array(
    '#type' => 'select',
    '#title' => 'Congressional District Override Field',
    '#default_value' => check_plain($field_cd_sunlight_civicrm_cd_override),
    '#options' => $fields,
    '#description' => t('Create a second alphanumeric text field (should be searchable and '
      . 'read/write) to allow administrators to manually override the value queried from '
      . 'Sunlight. '),
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Save',
  );
  return $form;

}

function cd_sunlight_settings_fields_form_validate($form, &$form_state) {

  // Check that both fields are in the same table.
  db_set_active('civicrm');
  $table_1 = db_result(db_query('SELECT custom_group_id FROM civicrm_custom_field
    WHERE id = %d', $form_state['values']['field_cd_sunlight_civicrm_cd']));
  $table_2 = db_result(db_query('SELECT custom_group_id FROM civicrm_custom_field
    WHERE id = %d', $form_state['values']['field_cd_sunlight_civicrm_cd_override']));
  db_set_active();
  if ($table_1 != $table_2) {
    form_set_error('field_cd_sunlight_civicrm_cd_override'
      , t('You must choose two fields from the same group.'));
  }
}

function cd_sunlight_settings_fields_form_submit($form, &$form_state) {

  // Retrieve the fields data.
  db_set_active('civicrm');
  $field_cd_sunlight_civicrm_cd = db_fetch_object(db_query('SELECT f.id, f.column_name, g.table_name
    FROM civicrm_custom_field f
    INNER JOIN civicrm_custom_group g
      ON f.custom_group_id = g.id
    WHERE f.id = %d', $form_state['values']['field_cd_sunlight_civicrm_cd']));
  $field_cd_sunlight_civicrm_cd_override = db_fetch_object(db_query('SELECT f.id, f.column_name, g.table_name
    FROM civicrm_custom_field f
    INNER JOIN civicrm_custom_group g
      ON f.custom_group_id = g.id
    WHERE f.id = %d', $form_state['values']['field_cd_sunlight_civicrm_cd_override']));
  db_set_active();

  // Save the variables.
  variable_set('cd_sunlight_civicrm_custom_table',
    $field_cd_sunlight_civicrm_cd->table_name);
  variable_set('cd_sunlight_civicrm_cd',
    'custom_'. $field_cd_sunlight_civicrm_cd->id);
  variable_set('cd_sunlight_civicrm_cd_override',
    'custom_'. $field_cd_sunlight_civicrm_cd_override->id);
  variable_set('cd_sunlight_civicrm_custom_field_cd',
    $field_cd_sunlight_civicrm_cd->column_name);
  variable_set('cd_sunlight_civicrm_custom_field_cd_override',
    $field_cd_sunlight_civicrm_cd_override->column_name);

  drupal_set_message(t('The fields have been saved.'));
}

/**
 * @category API
 */

/**
 * Queue a contact to have its CD retreived from Sunlight on the next cron run.
 *
 * @param $contact_id
 *  CiviCRM Conact ID.
 * @return none.
 */
function cd_sunlight_contact_enqueue($contact_id) {
  db_query('INSERT IGNORE INTO {cd_sunlight_cron} SET contact_id = %d', $contact_id);
}

/**
 * Dequeue a contact from CD Lookup.
 *
 * @param $contact_id
 *  CiviCRM Conact ID.
 * @return none.
 */
function cd_sunlight_contact_dequeue($contact_id) {
  db_query('DELETE FROM {cd_sunlight_cron} WHERE contact_id = %d', $contact_id);
}

/**
 * Get the CD of the given contact from the database.
 *
 * @param int $contact_id
 * @return string
 *  ex. 'NY17' or NULL if not set/error.
 */
function cd_sunlight_contact_get_cd($contact_id) {

  // Find the contact.
  $params = array(
    'contact_id' => $contact_id,
    'return.' . CD_SUNLIGHT_CIVICRM_CD => TRUE,
    'return.' . CD_SUNLIGHT_CIVICRM_CD_OVERRIDE => TRUE,
  );
  $contact = _cd_sunlight_civicrm_contact_get($params);
  if (civicrm_error($contact)) {
    $backtrace = _cd_sunlight_backtrace();
    watchdog('cd_sunlight', 'CiviCRM API error: @backtrace @contact',
      array('@backtrace' => $backtrace, '@contact' => $contact), WATCHDOG_ERROR,
      l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
    return FALSE;
  }
  elseif ($contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE]) {
    return $contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE];
  }
  elseif ($contact[CD_SUNLIGHT_CIVICRM_CD]) {
    return $contact[CD_SUNLIGHT_CIVICRM_CD];
  }
  return NULL;
}

/**
 * Get the contact's CD state.
 *
 * This is not the state stored in the contact's address,
 * rather the state portion of the CD ('NY17').
 *
 * @param int $contact_id
 * @return string
 *  ex. 'NY', or NULL if not set.
 */
function cd_sunlight_contact_get_state($contact_id) {
  $cd = cd_sunlight_contact_get_cd($contact_id);
  return cd_sunlight_cd_parse_state($cd);
}

/**
 * Get the contact's CD district.
 *
 * @param int $contact_id
 * @return int
 *  ex. 17 or NULL if not set.
 */
function cd_sunlight_contact_get_district($contact_id) {
  $cd = cd_sunlight_contact_get_cd($contact_id);
  return cd_sunlight_cd_parse_district($cd);
}

/**
 * Get the user's CD
 *
 * @param int $uid
 * @return string
 *  ex. 'NY17' or NULL if not set/error.
 */
function cd_sunlight_user_get_cd($uid) {
  if ($contact_id = _cd_sunlight_user_get_contact($uid)) {
    return cd_sunlight_contact_get_cd($contact_id);
  }
}

/**
 * Get the user's CD state.
 *
 * This is not the state stored in the contact's address,
 * rather the state portion of the CD ('NY17').
 *
 * @param int $uid
 * @return string
 *  ex. 'NY', or NULL if not set.
 */
function cd_sunlight_user_get_state($uid) {
  if ($contact_id = _cd_sunlight_user_get_contact($uid)) {
    return cd_sunlight_contact_get_state($contact_id);
  }
}

/**
 * Get the user's CD district.
 *
 * @param int $uid
 * @return int
 *  ex. 17 or NULL if not set.
 */
function cd_sunlight_user_get_district($uid) {
  if ($contact_id = _cd_sunlight_user_get_contact($uid)) {
    return cd_sunlight_contact_get_district($contact_id);
  }
}

/**
 * Get all information about a CD including all representatives and senators.
 *
 * NOTE: This only deals with the local DB.  If the legislators haven't yet been retreived for
 * this CD from the Sunlight API, then an empty array (or impartial array) will be returned.  This
 * will be rectified at the next cron run.
 *
 * @param string $cd
 *  The CD to fetch ex. 'NY17'.
 * @param array $return_properties = array('legislators')
 *  Linear array containing one or more of:
 *    'legislators'
 *    'users'
 *    'contacts'
 * @return array
 *  An array describing the CD, an empty array if none found, or FALSE on error.
 *  See cd_sunlight_legislators_get() for information on the format of legislators.
 *  "other stuff" possible with the Sunlight API includes getting all Zips within the CD,
 *  but we have no plans to implement this ATM.
 *
 *  ex.
 *  array(
 *    'state' => 'NY',
 *    'district' => 17,
 *    'cd' => 'CD17',
 *    'legislators' => array(
 *      123 => array(...),
 *      456 => array(...),
 *      789 => array(...),
 *    ),
 *    'maybe_other_stuff' => array(...),
 *    'maybe_more_other_stuff' => array(...),
 *  );
 */
function cd_sunlight_cd_load($cd, $return_properties = array('legislators')) {
  $return_properties = drupal_map_assoc($return_properties);

  // Sanity checking.
  if (!_cd_sunlight_validate_cd($cd)) {
    watchdog('cd_sunlight', 'Improper parameters for cd_sunlight_cd_load().', array(),
      WATCHDOG_ERROR);
    return FALSE;
  }

  $district = array(
    'state' => cd_sunlight_cd_parse_state($cd),
    'district' => cd_sunlight_cd_parse_district($cd),
    'cd' => $cd,
  );

  // Get legislators.
  if (isset($return_properties['legislators'])) {
    $district['legislators'] = _cd_sunlight_cd_get_legislators($cd);
  }

  // Get users.
  if (isset($return_properties['users'])) {
    $district['users'] = _cd_sunlight_cd_get_users($cd);
  }

  // Get contacts.
  if (isset($return_properties['contacts'])) {
    $district['contacts'] = _cd_sunlight_cd_get_contacts($cd);
  }

  return $district;
}

/**
 * Get a list of all CDs stored in the database.
 *
 * Includes CDs in CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD
 * and CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE
 *
 * @return array
 *  Simple array of CDs.
 */
function cd_sunlight_cd_all() {
  $cds = array();
  db_set_active('civicrm');
  $res = db_query('SELECT '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .' AS cd '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' '.
    'GROUP BY '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .
    ' UNION SELECT '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' AS cd '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' '.
    'GROUP BY '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE
  );
  db_set_active();
  while ($cd = db_fetch_object($res)) {
    if (!empty($cd->cd)) {
      $cds[] = $cd->cd;
    }
  }
  return $cds;
}

/**
 * Get the legislator(s) that match the given parameters.
 *
 * @param array $param
 *  A set of field => value pairs
 *  ex.
 *  array(
 *    'title' => 'Rep',
 *    'state' => 'NY',
 *    'district' => '17',
 *  );
 * @param array $order_by = array('state' => 'ASC', 'lastname' => 'ASC')
 *  How to order the results.
 * @return array
 *  An array of legislators, an empty array if none found, or FALSE on error.
 *  Each legislator is a secondary array of field => value pairs.
 *
 *  ex.
 *  array(
 *    123 => array(
 *      'firstname' => 'John',
 *      'lastname' => 'Henry',
 *      ...
 *    ),
 *    456 => array(
 *      'firstname' => 'Jane',
 *      'lastname' => 'Doe',
 *      ...
 *    ),
 *  );
 */
function cd_sunlight_legislators_get($params = array(), $order_by = array('state' => 'ASC', 'district' => 'ASC', 'lastname' => 'ASC')) {

  // Build WHERE.
  $where = _cd_sunlight_build_sql_clause($params, ' AND ');

  // If there was an error, return FALSE.
  if ($where === FALSE) {
    return FALSE;
  }

  // Build Query.
  $sql = 'SELECT * FROM {cd_sunlight_legislators} WHERE ' . $where . ' ORDER BY';

  // Order By.
  $order_array = array();
  foreach ($order_by as $field => $direction) {
    $order_array[] = ' %s %s';
    $params[] = $field;
    $params[] = $direction;
  }
  $sql .= implode(', ', $order_array);

  // Run Query.
  $res = db_query($sql, $params);
  $legislators = array();
  while ($legislator = db_fetch_array($res)) {
    $legislator['cd'] = _cd_sunlight_build_cd($legislator['state'], $legislator['district']);
    $legislators[$legislator['legislator_id']] = $legislator;
  }

  return $legislators;
}

/**
 * Given the CD, extract the characters for state
 *
 * @param string $cd
 *  ex. 'NY17'.
 * @return string
 *  ex. 'NY'
 */
function cd_sunlight_cd_parse_state($cd) {
  return drupal_substr($cd, 0, 2);
}

/**
 * Given the CD, extract the characters for district
 *
 * @param string $cd
 *  ex. 'NY17'.
 * @return int
 *  ex. 17
 */
function cd_sunlight_cd_parse_district($cd) {
  // Note that we can't use substr($cd, -2) because the district might only be one digit.
  return drupal_substr($cd, 2);
}

/**
 * Validate the given CD data.
 *
 * Only validates for proper format, not that the CD actually exists.  If the CD is found to be bad,
 * the contact will be queued for lookup.
 *
 * @param array $contact
 *  Does not need to be a full CiviCRM contact.  Just a simple array with keys for
 *    contact_id
 *    CD_SUNLIGHT_CIVICRM_CD
 *    CD_SUNLIGHT_CIVICRM_CD_OVERRIDE
 * @return none
 */
function cd_sunlight_validate_civicrm_data($contact) {

  // CDs in the DB that validate, but don't actually exist.
  static $bad_cds = array('NY99');

  // We need to make copies because the validators modify the passed values.
  $cd = $contact[CD_SUNLIGHT_CIVICRM_CD];
  $cd_override = $contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE];
  $cd_is_valid = _cd_sunlight_validate_cd($cd);
  $cd_override_is_valid = _cd_sunlight_validate_cd($cd_override);

  // If the CD has never been looked up, then queue for lookup.
  if ($cd === NULL) {
    cd_sunlight_contact_enqueue($contact['contact_id']);
    return;
  }

  // If the CD or CD override were not a valid format, then reset it to '' and queue for lookup.
  if (!$cd_is_valid || !$cd_override_is_valid) {
    $cd = ($cd_is_valid ? $cd : '');
    $cd_override = ($cd_override_is_valid ? $cd_override : '');
    _cd_sunlight_contact_set_cd($contact['contact_id'], $cd, $cd_override);
    cd_sunlight_contact_enqueue($contact['contact_id']);
    return;
  }

  // If the CD is one of the known validating bad ones, reset it to '' and queue for lookup.
  $bad = FALSE;
  if (in_array($cd, $bad_cds)) {
    $cd = '';
    $bad = TRUE;
  }
  if (in_array($cd_override, $bad_cds)) {
    $cd_override = '';
    $bad = TRUE;
  }
  if ($bad) {
    _cd_sunlight_contact_set_cd($contact['contact_id'], $cd, $cd_override);
    cd_sunlight_contact_enqueue($contact['contact_id']);
    return;
  }

  // If the validator was able to convert the CD to the proper format, then save it.
  if (
    $cd != $contact[CD_SUNLIGHT_CIVICRM_CD] ||
    $cd_override != $contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE]
  ) {
    _cd_sunlight_contact_set_cd($contact['contact_id'], $cd, $cd_override);
    return;
  }

}

/**
 * Run the CiviCRM geocoding script.
 *
 * @param string $username
 *  CiviCRM cron scripts require authentication against a Drupal user/pass.
 * @param string $password
 *  CiviCRM cron scripts require authentication against a Drupal user/pass.
 *  Leave FALSE when running cron.
 * @param string $map_provider = 'Google'
 * @param string $map_API_key = ''
 *  your key, or 'googlemap_api_key' to use the key set by the GMap module.
 * @param mixed $number_of_contacts = 300
 *  The maximum number of contacts to be geocoded.
 *  'all' to geocode all contacts that do not have lat/long.
 * @return object
 *  an HTTP response object.  We've already logged the response, you can do further work with it
 *  if you'd like.
 */
function cd_sunlight_contacts_geocode($number_of_contacts = 300) {

  civicrm_initialize();

  // Sanity checking.
  if (
    !variable_get('cd_sunlight_geocode_username', '') ||
    !defined('CD_SUNLIGHT_GEOCODE_PASSWORD') ||
    !defined('CIVICRM_SITE_KEY') ||
    !_cd_sunlight_crypt_enabled()
  ) {
    watchdog('cd_sunlight', 'Batch geocoding has not been setup.  Please check the ' .
      '<a href="!url">settings</a>.', array('!url' => '/admin/settings/cd_sunlight'), WATCHDOG_ERROR);
  }

  watchdog('cd_sunlight', 'Batch geocoding CiviCRM contacts', array(), WATCHDOG_INFO);

  // Get the start and end IDs.
  if ($number_of_contacts == 'all') {
    $start_id = 0;
  }
  else {
    db_set_active('civicrm');
    $start_id = db_result(db_query('SELECT contact_id
      FROM civicrm_address
      WHERE geo_code_1 is null
        AND state_province_id IS NOT NULL
        AND country_id IS NOT NULL
      ORDER BY contact_id
      LIMIT 1'));
    if (empty($start_id)) {
      $start_id = 0;
    }
    $end_id = db_result(db_query('SELECT MAX(contact_id)
      FROM (
        SELECT contact_id
        FROM civicrm_address a
        INNER JOIN civicrm_state_province s
          ON a.state_province_id = s.id
        WHERE contact_id > %d
          AND geo_code_1 IS NULL
          AND a.country_id IS NOT NULL
        ORDER BY contact_id
        LIMIT %d
      )a',
      $start_id, $number_of_contacts));
    db_set_active();
  }

  // Build script parameters.
  $query = array(
    'name' => _cd_sunlight_crypt_decrypt(variable_get('cd_sunlight_geocode_username', '')),
    'pass' => CD_SUNLIGHT_GEOCODE_PASSWORD,
    'key' => CIVICRM_SITE_KEY,
    'start' => $start_id,
  );
  if (!empty($end_id)) {
    $query['end'] = $end_id;
  }
  $query_string = drupal_query_string_encode($query);
  $script = drupal_get_path('module', 'civicrm') . '/../bin/UpdateAddress.php';
  $url = url($script, array('query' => $query_string, 'absolute' => TRUE));

  // Run the CiviCRM cron script.
  $response = drupal_http_request($url, array(), 'GET', NULL, 3, 600);

  // Log results.
  if ($response->code == 200 && strpos($response->data, 'Addresses Geocoded :') !== FALSE) {
    watchdog('cd_sunlight', '@data', array('@data' => $response->data), WATCHDOG_NOTICE);
  }
  else {
    // Rebuild the URL without the key or password to give the admin some feedback.
    $query['pass'] = 'XXXX';
    $query['key'] = 'XXXX';
    $query_string = drupal_query_string_encode($query);
    $url = url($script, array('query' => $query_string, 'absolute' => TRUE));
    watchdog('cd_sunlight',
      'Error during contact geocoding: %error',
      array('%error' => $response->code . ': ' . $response->error . '; ' . $response->data . ' ' . $url),
      WATCHDOG_ERROR);
  }

  return $response;
}

/**
 *  @category INTERNAL PRIVATE FUNCTIONS
 */

/**
 * Validate a CD (only the format, not if it actually exists).
 *
 * We ignore NULL CDs.  All other empty values are converted to ''.
 *
 * @param string $cd
 * @return boolean
 *  TRUE on success (and $cd may be manipulated to fit our format) else FALSE.
 */
function _cd_sunlight_validate_cd(&$cd) {

  // A NULL CD is valid.
  if ($cd === NULL) {
    return TRUE;
  }
  // Other blanks are valid, but change to ZLS for consistency.
  if (empty($cd)) {
    $cd = '';
    return TRUE;
  }

  // Remove non-alphanumerics.
  $cd = preg_replace("/[^a-zA-Z0-9]/", '', $cd);

  // We have to split things up so that state gets forced to be upper case.
  $state = cd_sunlight_cd_parse_state($cd);
  $district = cd_sunlight_cd_parse_district($cd);

  if (_cd_sunlight_validate_state($state) === FALSE) {
    return FALSE;
  }
  elseif (_cd_sunlight_validate_district($state, $district) === FALSE) {
    return FALSE;
  }

  $cd = $state . $district;
  return TRUE;
}

/**
 * Build a CD from the given State and district.
 *
 * @param string $state
 * @param mixed $district
 *  Can be an int or a number as a string.
 * @return mixed
 *  A CD or FALSE if things went terribly wrong.
 */
function _cd_sunlight_build_cd($state, $district) {

  // Remove non-alphanumerics.
  $state = preg_replace("/[^a-zA-Z]/", '', $state);
  $district = preg_replace("/[^0-9]/", '', $district);

  if (_cd_sunlight_validate_state($state) === FALSE) {
    return FALSE;
  }
  elseif (_cd_sunlight_validate_district($state, $district) === FALSE) {
    return FALSE;
  }

  return $state . $district;
}

/**
 * Validate a state (only the format, not if it actually exists).
 *
 * @param string $state
 * @return boolean
 *  TRUE on success (and $state may be manipulated to fit our format) else FALSE.
 */
function _cd_sunlight_validate_state(&$state) {
  $state = drupal_strtoupper($state);
  return ctype_alpha($state) && drupal_strlen($state) === 2;
}

/**
 * Validate a district (only the format, not if it actually exists).
 * Removes leading zeros.
 *
 * @param string $state
 * @param string &$district
 * @return boolean
 *  TRUE on success (and $district may be manipulated to fit our format) else FALSE.
 */
function _cd_sunlight_validate_district($state, &$district) {
  if (in_array($state, _cd_sunlight_state_list_at_large())) {
    $district = 0;
    return TRUE;
  }
  $district = ltrim($district, '0');
  $district_len = drupal_strlen($district);
  return ctype_digit((string)$district) && ($district_len === 2 || $district_len === 1);
}

/**
 * Convert a set of field => value statements into a string formatted for db_query().
 *
 * @param array $params
 *  A set of field => value pairs.  Must include at least one pair.
 *
 *  ex.
 *  array(
 *    'title' => 'Rep',
 *    'state' => 'NY',
 *    'district' => '17',
 *  );
 * @param string, $implode_string
 *  usually ', ', or ' AND '
 * @return string
 *  ex. 'foo = "%s" AND bar = %d' or FALSE on error.
 */
function _cd_sunlight_build_sql_clause($params, $implode_string) {

  // Sanity Checking.
  if (!is_array($params) || !count($params)) {
    watchdog('cd_sunlight', 'Improper parameters for _cd_sunlight_build_sql_clause().', array(),
      WATCHDOG_ERROR);
    return FALSE;
  }

  // Build SQL.
  $where = array();
  foreach ($params as $field => &$value) {
    if (is_string($value)) {
      $where[] = db_escape_string($field) .' = "%s"';
    }
    else {
      $where[] = db_escape_string($field) .' = %d';
    }
  }
  return implode($implode_string, $where);
}

/**
 * Delete the legislator(s) that match the given parameters.
 *
 * @param array $param
 *  A set of field => value pairs
 *  ex.
 *  array(
 *    'title' => 'Rep',
 *    'state' => 'NY',
 *    'district' => '17',
 *  );
 */
function _cd_sunlight_legislator_delete($params) {

  // Build WHERE.
  $where = _cd_sunlight_build_sql_clause($params, ' AND ');

  // If there was an error, return FALSE.
  if ($where === FALSE) {
    return FALSE;
  }

  // Run Query.
  $sql = 'DELETE FROM {cd_sunlight_legislators} WHERE ' . $where;
  db_query($sql, $params);
}

/**
 * Save the legislator.
 *
 * @param array $legislator
 *  A set of field => value pairs as returned by the Sunlight API
 *  ex.
 *  array(
 *    'title' => 'Rep',
 *    'state' => 'NY',
 *    'district' => '17',
 *    'firstname' => 'Jane',
 *    'lastname' => 'Doe',
 *    ...
 *  );
 * @return boolean
 *  TRUE on success, else FALSE.
 */
function _cd_sunlight_legislator_save($legislator) {

  // Sanity Checking.
  if (!is_array($legislator) || !count($legislator)) {
    watchdog('cd_sunlight', 'Improper parameters for _cd_sunlight_legislator_save().', array(),
      WATCHDOG_ERROR);
    return FALSE;
  }

  drupal_write_record('cd_sunlight_legislators', $legislator);

}

/**
 * Trim a legislator array to only the known fields.
 *
 * Sunlight occassionally comes out with new fields, so we need to filter out only the ones that
 * we can insert in the database.
 *
 * NOTE: Keep this list in synch with the database.
 *
 * @param array $legislator
 *  A legislator array as returned from sunlight.
 * @return array
 *  The trimmed legislator
 * @todo we can now use schema API for this.
 */
function _cd_sunlight_legislator_filter_fields($legislator) {
  static $fields = array();

  if (empty($fields)) {
    $schema = drupal_get_schema_unprocessed('cd_sunlight', 'cd_sunlight_legislators');
    $fields = $schema['fields'];
  }
  return array_intersect_key($legislator, $fields);
}

/**
 * Lookup the user's CiviCRM contact_id
 *
 * @param integer $uid
 * @return mixed $contact_id
 *  Integer if it exists, else NULL
 */
function _cd_sunlight_user_get_contact($uid) {
    civicrm_initialize();
    require_once('api/UFGroup.php');
    if (!($contact_id = crm_uf_get_match_id($uid))) {
      watchdog('cd_sunlight', 'CiviCRM API error.  Could not find a contact for uid '. $uid ,
        array(), WATCHDOG_WARNING
      );
      return NULL;
    }
    return $contact_id;
}

/**
 * Update all info about a CD or State by retreiving it from the Sunlight API.
 *
 * Currently this is only legislators.  But the API could be used to retreive all zip codes in
 * a CD as well.
 *
 * Note that we only care about legislators in office, not dead/defeated/retired ones.
 *
 * @param $zone
 *  either 'state' or 'cd'
 * @param $name
 *  ex. 'NY' or 'NY17'.
 * @return boolean
 *  TRUE on success, else FALSE.
 */
function _cd_sunlight_zone_update($zone, $name) {

  // Sanity checking.
  if ($zone == 'cd') {
    if (!_cd_sunlight_validate_cd($name)) {
      watchdog(
        'cd_sunlight',
        'Improper parameters for _cd_sunlight_zone_update(): %name is not a CD.',
        array('%name' => $name),
        WATCHDOG_ERROR
      );
      return FALSE;
    }
    $state = cd_sunlight_cd_parse_state($name);
    $district = cd_sunlight_cd_parse_district($name);
  }
  elseif ($zone == 'state') {
    if (!_cd_sunlight_validate_state($name)) {
      watchdog(
        'cd_sunlight',
        'Improper parameters for _cd_sunlight_zone_update(): %name is not a state.',
        array('%name' => $name),
        WATCHDOG_ERROR
      );
      return FALSE;
    }
    $state = $name;
  }
  else {
    watchdog(
      'cd_sunlight',
      'Improper parameters for _cd_sunlight_zone_update(). ',
      array(),
      WATCHDOG_ERROR
    );
    return FALSE;
  }

  // Abort on special states.
  if (in_array($state, _cd_sunlight_state_list_with_no_congresspersons())) {
    return TRUE;
  }

  // Lookup the legislators for this zone.
  if ($zone == 'cd') {
    $params = array(
      'title' => 'Rep',
      'state' => $state,
    );
    // Some may have $district == 0 (states with just one district).
    if ($district) {
      $params['district'] = $district;
    }
  }
  else {
    $params = array(
      'title' => 'Sen',
      'state' => $state,
    );
  }
  if (in_array($state, _cd_sunlight_state_list_with_non_voting_congresspersons())) {
    unset($params['title'], $params['district']);
  }
  $legislators = _cd_sunlight_legislators_apilookup($params);
  if ($legislators === FALSE) {
    watchdog('cd_sunlight', 'Could not lookup legislators for %zone - %name',
      array('%zone' => $zone, '%name' => $name),
      WATCHDOG_ERROR
    );
    return FALSE;
  }
  if (!count($legislators)) {
    watchdog('cd_sunlight', 'There are currently no legislators for %zone - %name',
      array('%zone' => $zone, '%name' => $name));
  }

  // Because we only care about current legislators, delete any previous matching records.
  _cd_sunlight_legislator_delete($params);

  // Save our new legislators.
  $error = FALSE;
  foreach ($legislators as $legislator) {
    if (_cd_sunlight_legislator_save($legislator)) {
      $error = TRUE;
    }
  }

  // Return something.
  if ($error) {
    watchdog('cd_sunlight', 'Could not save new legislator data to %zone - %name',
      array('%zone' => $zone, '%name' => $name),
      WATCHDOG_ERROR
    );
    return FALSE;
  }
  return TRUE;
}

/**
 * Query the Sunlight API service and retrieve legislators that match the given parameters.
 *
 * @param array $params
 *  should look something like:
 *    array(
 *      'title' => 'Rep',
 *      'state' => 'NY',
 *      'district' => '17',
 *    );
 * @return array or FALSE on error
 *  ex.
 *    array(
 *      0 => array(
 *        'title' => 'Rep',
 *        'state' => 'NY',
 *        'district' => '17',
 *        'firstname' => 'Jane',
 *        'lastname' => 'Doe',
 *        ...
 *      ),
 *      1 => array(
 *        'title' => 'Sen',
 *        'state' => 'NY',
 *        'firstname' => 'John',
 *        'lastname' => 'Doe',
 *        ...
 *      ),
 *    );
 */
function _cd_sunlight_legislators_apilookup($params) {
  $error_message = '';
  $result = _cd_sunlight_api_lookup('legislators.getList', $params, $error_message);
  if ($result === FALSE) {
    watchdog('cd_sunlight', 'Error from Sunlight: @data.  For legislator lookup: @query',
      array('@data' => $error_message, '@query' => var_export($params, TRUE)), WATCHDOG_ERROR);
  }
  return $result;
}

/**
 * Query the Sunlight API service and lookup the CD for the contact.
 *
 * @param array $contact
 *  Must have a contact_id.
 *  Must have postal_code/zip or latitude&longitude/geo_code_1&geo_code_2.
 *  street_address and country_id and state_province_id are suggested.
 * @return mixed
 *  FALSE on error
 *  NULL if there was not enough data passed in to perform a lookup
 *  else a $cd_data array which may be empty if no CD was found:
 *    array(
 *      'state' => 'NY',
 *      'district' => '17',
 *    );
 */
function _cd_sunlight_contact_apilookup($contact) {

  // Sanity checking.
  if (!is_array($contact) || empty($contact['contact_id'])) {
    watchdog('cd_sunlight', 'No contact_id for _cd_sunlight_contact_apilookup: @contact',
      array('@contact' => var_export($contact, TRUE)), WATCHDOG_ERROR);
    return NULL;
  }
  // Is country US?
  if (
    isset($contact['country_id']) &&
    $contact['country_id'] != CD_SUNLIGHT_CIVICRM_US_COUNTRY_ID
  ) {
    return NULL;
  }
  // Is state NON-US?
  if (
    isset($contact['state_province_id']) &&
    $contact['state_province_id'] == CD_SUNLIGHT_CIVICRM_NON_US_STATE_PROVINCE_ID
  ) {
    return NULL;
  }

  $zip = !empty($contact['postal_code']) ? $contact['postal_code'] :
    (!empty($contact['zip']) ? $contact['zip'] : '');
  $latitude = !empty($contact['geo_code_1']) ? $contact['geo_code_1'] :
    (!empty($contact['latitude']) ? $contact['latitude'] : '');
  $longitude = !empty($contact['geo_code_2']) ? $contact['geo_code_2'] :
    (!empty($contact['longitude']) ? $contact['longitude'] : '');
  $contact_id = $contact['contact_id'];

  // Decide what method to call based on what paramaters we have.
  // Lat/Long is preferred, but can only be trusted if the contact has an address or postal code.
  // Otherwise the geocoding was based off city/state/country which is useless to us.
  if (!empty($latitude) && !empty($longitude) && (!empty($zip) || !empty($street_address))) {

    // Contact ID is included for debugging purposes.
    // If there's an error it will show up in watchdog.
    $params = array(
      'latitude' => $latitude,
      'longitude' => $longitude,
      'contact_id' => $contact_id,
    );
    $error_message = '';
    $cd_data = _cd_sunlight_api_lookup('districts.getDistrictFromLatLong', $params, $error_message);

    // We have a special edge case where sometimes, if a point is on the edge of the country
    // (usually an ocean) it may lie outside of the polygon.  In these cases we will re-run the
    // lookup but only use the zip.
    if (
      $cd_data === FALSE && (
        strpos($error_message, 'Point not within a congressional district') !== FALSE ||
        strpos($error_message, 'Invalid Parameter') !== FALSE
      )
    ) {
      if (empty($zip)) {
        return NULL;
      }
      watchdog('cd_sunlight',
        'Point not within a congressional district, trying again with only zip: @params',
        array('@params' => var_export($params, TRUE)),
        WATCHDOG_NOTICE,
        l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $params['contact_id'])));
      unset($contact['geo_code_1'], $contact['geo_code_2'],
        $contact['latitude'], $contact['longitude']);
      return _cd_sunlight_contact_apilookup($contact);
    }

  }
  elseif (!empty($zip)) {

    // Contact ID is included for debugging purposes.
    // If there's an error it will show up in watchdog.
    $params = array(
      'zip' => $zip,
      'contact_id' => $contact_id,
    );
    $cd_data = _cd_sunlight_api_lookup('districts.getDistrictsFromZip', $params);
  }
  else {
    watchdog('cd_sunlight',
      'This contact does not have enough address info to do a lookup: @contact',
      array('@contact' => var_export($contact, TRUE)),
      WATCHDOG_NOTICE,
      l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
    return NULL;
  }

  // Sanity checking.
  if ($cd_data === FALSE) {
    watchdog('cd_sunlight', 'Error from Sunlight: @data.  For CD lookup: @query @response',
      array('@data' => $error_message, '@query' => var_export($params, TRUE), '@response' => var_export($response, TRUE)),
      WATCHDOG_ERROR);
    return FALSE;
  }
  if (empty($cd_data)) {
    return array();
  }

  // There may be more than one CD per zip.
  // Right now we are just going to take the first one.  We might consider doing something else
  // later.
  $cd_data = current($cd_data);

  // Sunlight is inconsistent with its naming.  This is the only place that it uses the term
  // "number" rather than "district".  We'll change it to be more consistent.
  $cd_data['district'] = $cd_data['number'];
  unset($cd_data['number']);

  return $cd_data;
}

/**
 * Query Sunlight to find the CD for the given contact. Then store it.
 *
 * @param int $contact_id.
 * @return mixed
 *  FALSE if there was an error or if the CD could not be found.
 *  NULL if there was not enough contact data to perform a lookup.
 *  Else the CD returned by Sunlight ex. 'NY17'.
 */
function _cd_sunlight_contact_cd_update($contact_id) {

  // Load the contact.
  $params = array(
    'contact_id' => $contact_id,
    'return.postal_code' => TRUE,
    'return.latitude' => TRUE,
    'return.longitude' => TRUE,
    'return.geo_code_1' => TRUE,
    'return.geo_code_2' => TRUE,
    'return.street_address' => TRUE,
    'return.state_province' => TRUE,
    'return.country' => TRUE,
    'return.'. CD_SUNLIGHT_CIVICRM_CD_OVERRIDE => TRUE,
    'return.'. CD_SUNLIGHT_CIVICRM_CD => TRUE,
  );
  $contact = _cd_sunlight_civicrm_contact_get($params);
  if (civicrm_error($contact)) {
    watchdog('cd_sunlight', 'Error loading contact in cd_lookup_civicrm_pre()', array(),
      WATCHDOG_ERROR,
      l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
    return array();
  }

  // Get the data from Sunlight.
  $cd_data = _cd_sunlight_contact_apilookup($contact);
  if ($cd_data === FALSE) {
    // There was an error.
    return FALSE;
  }
  elseif ($cd_data === NULL) {
    // We didn't pass in enough data.
    cd_sunlight_contact_dequeue($contact_id);
    return NULL;
  }
  elseif (empty($cd_data)) {
    // No CD was found by Sunlight.
    // This part is tricky, since we want to keep the old CD if the user wiped their address,
    // But if this is a brand-new lookup, then we should save '' to the field.
    if (!isset($contact[CD_SUNLIGHT_CIVICRM_CD]) || $contact[CD_SUNLIGHT_CIVICRM_CD] === NULL) {
      $cd = '';
    }
    else {
      cd_sunlight_contact_dequeue($contact_id);
      return FALSE;
    }
  }
  else {
    // Do something with the data.
    $cd = _cd_sunlight_build_cd($cd_data['state'], $cd_data['district']);
    if (empty($cd)) {
      watchdog('cd_sunlight', 'Could not build a CD for contact: @contact @cd_data',
        array('@contact' => var_export($contact, TRUE), '@cd_data' => var_export($cd_data, TRUE)),
        WATCHDOG_ERROR,
        l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
      return FALSE;
    }
  }

  // Save it.
  $override = !empty($contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE]) ?
    $contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE] : NULL;
  if (_cd_sunlight_contact_set_cd($contact['contact_id'], $cd, $override)) {
    cd_sunlight_contact_dequeue($contact_id);
    return $cd;
  }
  watchdog('cd_sunlight', 'Error saving contact: @contact @cd_data'.
    array('@contact' => var_export($contact, TRUE), '@cd_data' => var_export($cd_data, TRUE)),
    WATCHDOG_ERROR,
    l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id)));
  return FALSE;

}

/**
 * Semaphore used to prevent expensive operations from running when a contact is being processed.
 *
 * @param boolean $set_state
 *  To set whether _cd_sunlight_contact_set_cd() is running, pass in TRUE or FALSE,
 *  or nothing to get the current status.
 * @return boolean
 */
function _cd_sunlight_contact_set_cd_is_running($set_state = NULL) {
  static $semaphore = FALSE;
  if ($set_state !== NULL) {
    $semaphore = $set_state;
  }
  return $semaphore;
}

/**
 * Set the given contact's CD.
 *
 * @param int $contact_id
 * @param string $cd = NULL
 *  Ex. 'NY17'.
 *  Set '' to clear any previous values.
 *  Set NULL to avoid overwriting existing values.
 *  Value must already be validated
 * @param string $override = NULL
 *  Value to set for CD_SUNLIGHT_CIVICRM_CD_OVERRIDE
 *  Ex. 'NY17'.
 *  Set '' to clear any previous values.
 *  Set NULL to avoid overwriting existing values.
 *  Value must already be validated
 * @return boolean
 *  TRUE on success, else FALSE.
 */
function _cd_sunlight_contact_set_cd($contact_id, $cd = NULL, $override = NULL) {

  // Sanity check.
  // If nothing was passed in, just return TRUE.
  if (is_null($cd) && is_null($override)) {
    watchdog(
      'cd_sunlight',
      'No CD information save to contact.',
      array(),
      WATCHDOG_NOTICE,
      l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id))
    );
    return TRUE;
  }

  civicrm_initialize();
  require_once('api/v2/Contact.php');

  // Set the contact.
  $contact = array(
    'contact_id' => $contact_id,
    'contact_type' => 'Individual',
  );
  if (!is_null($cd)) {
    $contact[CD_SUNLIGHT_CIVICRM_CD] = $cd;
  }
  if (!is_null($override)) {
    $contact[CD_SUNLIGHT_CIVICRM_CD_OVERRIDE] = $override;
  }

  _cd_sunlight_contact_set_cd_is_running(TRUE);
  if (civicrm_error($contact = civicrm_contact_add($contact))) {
    $backtrace = _cd_sunlight_backtrace();
    watchdog('cd_sunlight', __LINE__ . ': CiviCRM API error: @backtrace @contact',
      array('@backtrace' => $backtrace, '@contact' => $contact), WATCHDOG_ERROR,
      l('view', 'civicrm/contact/view', array('query' => 'reset=1&cid='. $contact_id))
    );
    _cd_sunlight_contact_set_cd_is_running(FALSE);
    return FALSE;
  }
  _cd_sunlight_contact_set_cd_is_running(FALSE);
  return TRUE;
}

/**
 * Query the Sunlight API
 *
 * @param string $method
 *  What Sunlight API method to use.
 * @param array $params
 *  Paramaters to pass to the API.
 * @param string &$error_message = ''
 *  On error this will be populated with an error message.  Useful for debugging.
 *  This string should be treated as unsafe and run through check_plain and the like before display.
 * @return mixed
 *  array of data or FALSE on error.
 */
function _cd_sunlight_api_lookup($method, $params, &$error_message = '') {

  // Sanity checking.
  if (!is_array($params) || !count($params)) {
    $error_message = 'Attempting to query Sunlight with no params. ';
    watchdog('cd_sunlight', '@error_message', array('@error_message' => $error_message),
      WATCHDOG_ERROR);
    return FALSE;
  }

  // Convert params into a query string.
  $params['apikey'] = variable_get('cd_sunlight_api_key', '');
  $query = drupal_query_string_encode($params);

  // Call the URL and check for errors.
  $url = url('http://services.sunlightlabs.com/api/'. $method .'.json', array('query' => $query));
  $response = drupal_http_request($url);

  if ($response->code == 400) {
    // The connection was successful, but Sunlight encountered an error.
    // When Sunlight encounters an error it sends code 400 and an error message in the data.
    // We don't watchdog here because we gracefully handle errors in the calling function.
    $error_message = $response->data;
    return FALSE;
  }
  elseif (!empty($response->error) || $response->code != 200) {
    // The connection was unsuccessful for whatever reason.
    watchdog('cd_sunlight', 'Connection to Sunlight was unsuccessful: @code : @data',
      array('@data' => $response->error, '@code' => $response->code), WATCHDOG_ERROR);
    $error_message = t('Connection to Sunlight was unsuccessful: @code', array('@code' => $response->code));
    return FALSE;
  }

  // Parse the JSON.
  $result = json_decode($response->data, TRUE);
  if (empty($result)) {
    $error_message = 'Sunlight did not return JSON data. ';
    watchdog('cd_sunlight', '@error_message', array('@error_message' => $error_message),
      WATCHDOG_ERROR);
    return FALSE;
  }

  // Make this deep array easier to work with.
  $result = current(current($result));

  // If there are no results for our query $result will just be an empty array.
  $new_array = array();
  foreach ($result as $key => $value) {
    $new_array[$key] = current($value);
  }

  return $new_array;

}

/**
 * Update the info for all legislators.
 *
 * Cron calls this, perhaps nightly.  This should take 30-120 seconds to complete.
 *
 * @return none
 */
function _cd_sunlight_zone_update_all() {

  watchdog('cd_sunlight', 'Updating all members of congress', array(), WATCHDOG_INFO);

  // Get a list of all states and fetch the senators for those states.
  require_once('CRM/Core/PseudoConstant.php');
  $district_count = 0;
  $state_count = 0;
  $states = CRM_Core_PseudoConstant::stateProvinceAbbreviation();
  foreach ($states as $state) {
    if (_cd_sunlight_zone_update('state', $state)) {
      $state_count ++;
    }

    // Give things a chance to catch up, don't clobber Sunlight.
    _cd_sunlight_sleep();
  }

  // Get a list of all CDs and fetch the representatives for those CDs.
  $cds = cd_sunlight_cd_all();
  foreach ($cds as $cd) {
    if (_cd_sunlight_zone_update('cd', $cd)) {
      $district_count++;
    }

    // Give things a chance to catch up, don't clobber Sunlight.
    _cd_sunlight_sleep();
  }
  watchdog('cd_sunlight', "Updated data for $state_count states and $district_count CDs.");

}

/**
 * Return a list of all states that contain only one CD.
 *
 * @return array
 *  simple array of state abbreviations.
 */
function _cd_sunlight_state_list_at_large() {
  static $states = array(
    'AK', 'DE', 'MT', 'ND', 'SD', 'VT', 'WY',
    'AA', 'AE', 'AP', 'MP', 'UM', 'XX', // _cd_sunlight_state_list_with_no_congresspersons()
    'AS', 'DC', 'GU', 'MP', 'VI', 'PR', // _cd_sunlight_state_list_with_non_voting_congresspersons()
  );
  return $states;
}

/**
 * Return a list of all states that have no congresspersons.
 *
 * @return array
 *  simple array of state abbreviations.
 */
function _cd_sunlight_state_list_with_no_congresspersons() {
  // 'XX' is our special "non-us citizen" state.
  static $states = array('AA', 'AE', 'AP', 'MP', 'UM', 'XX', );
  return $states;
}

/**
 * Return a list of all states that have no voting congresspersons,
 * These special positions come under a variety of titles.
 * Hence when updating these states we search only by state and not title.
 *
 * @return array
 *  simple array of state abbreviations.
 */
function _cd_sunlight_state_list_with_non_voting_congresspersons() {
  static $states = array('AS', 'DC', 'GU', 'MP', 'VI', 'PR', );
  return $states;
}

/**
 * Lookup and store CD for queued contacts.
 *
 * @return none
 */
function _cd_sunlight_process_queue() {

  // Do geocoding if necessary.
  if (variable_get('cd_sunlight_geocoding_off', FALSE)) {
    cd_sunlight_contacts_geocode();

    // Hooks don't fire during CiviCRM cron scripts.  Enqueue all contacts that have lat/long,
    // but not a CD.
    db_set_active('civicrm');
    $res = db_query('SELECT a.contact_id '.
      'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' c '.
      'INNER JOIN civicrm_address a '.
        'ON c.entity_id = a.contact_id '.
      'WHERE ('.
          'c.'. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .' IS NULL OR '.
          'c.'. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .' = "" '.
        ') '.
        'AND ('.
          'a.geo_code_1 IS NOT NULL AND '.
          'a.geo_code_1 <> ""'.
        ') AND '.
        'a.country_id = '. CD_SUNLIGHT_CIVICRM_US_COUNTRY_ID .' AND '.
        'a.state_province_id <> '. CD_SUNLIGHT_CIVICRM_NON_US_STATE_PROVINCE_ID .' AND ('.
          'a.postal_code IS NOT NULL OR '.
          'a.street_address IS NOT NULL '.
        ')'
      );
      db_set_active();
      while ($contact = db_fetch_object($res)) {
        cd_sunlight_contact_enqueue($contact->contact_id);
      }

  }

  watchdog('cd_sunlight', 'Processing queued CD lookups', array(), WATCHDOG_INFO);

  // Update our CDs.
  civicrm_initialize();
  require_once('api/v2/Contact.php');
  $results = db_query_range('SELECT contact_id FROM {cd_sunlight_cron}', 0, 300);
  $x = 0;
  while ($queue = db_fetch_object($results)) {

    // Get the goods!
    _cd_sunlight_contact_cd_update($queue->contact_id);

    // Give things a chance to catch up, don't clobber Sunlight.
    _cd_sunlight_sleep();
    $x++;
  }
  if ($x > 0) {
    watchdog('cd_sunlight', 'Cron has processed '. $x .' records.');
  }
}

/**
 * Load the legislators for the given state.
 *
 * @param string $cd
 * @return array
 */
function _cd_sunlight_cd_get_legislators($cd) {
  $legislators = array();

  // Sanity checking.
  if (!_cd_sunlight_validate_cd($cd) || empty($cd)) {
    return $legislators;
  }
  $state = cd_sunlight_cd_parse_state($cd);
  $district = cd_sunlight_cd_parse_district($cd);

  // Get Representatives.  Note that we must do Reps and Sens separate since Reps require a
  // district and Sens don't.
  $params = array(
    'title' => 'Rep',
    'state' => $state,
    'district' => $district,
  );
  $representatives = cd_sunlight_legislators_get($params);

  // Get Senators.
  $params = array(
    'title' => 'Sen',
    'state' => $state,
  );
  $senators = cd_sunlight_legislators_get($params);

  $legislators = array_merge($representatives, $senators);

  // Non voting states have legislators that won't have been returned yet.
  if (in_array($state, _cd_sunlight_state_list_with_non_voting_congresspersons())) {
    $params = array(
      'state' => $state,
    );
    $other_legislators = cd_sunlight_legislators_get($params);
    $legislators = array_merge($legislators, $other_legislators);
  }

  return $legislators;
}

/**
 * Get all the contacts within the given CD
 *
 * @todo This may have big performance problems and may need to be cached.
 *
 * @param string $cd
 * @return array
 */
function _cd_sunlight_cd_get_contacts($cd) {
  $contacts = array();

  // Sanity checking.
  if (!_cd_sunlight_validate_cd($cd) || empty($cd)) {
    return $contacts;
  }

  db_set_active('civicrm');
  $sql = 'SELECT entity_id AS contact_id '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' '.
    'WHERE '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .' = "%s" '.
    '  AND ('.
         CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' IS NULL'.
    '    OR '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' = ""'.
    '  ) '.
    'UNION SELECT entity_id AS contact_id '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' '.
    'WHERE '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' = "%s" ';
  $res = db_query($sql,
    $cd, $cd
  );
  db_set_active();
  while ($contact = db_fetch_object($res)) {
    if (!empty($contact->contact_id)) {
      $contacts[] = $contact->contact_id;
    }
  }
  return $contacts;
}

/**
 * Get all the users within the given CD
 *
 * @todo This may have big performance problems and may need to be cached.
 *
 * @param string $cd
 * @return array
 */
function _cd_sunlight_cd_get_users($cd) {
  $users = array();

  // Sanity checking.
  if (!_cd_sunlight_validate_cd($cd) || empty($cd)) {
    return $users;
  }

  db_set_active('civicrm');
  $sql = 'SELECT m.uf_id AS uid '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' c '.
    'INNER JOIN civicrm_uf_match m'.
    '  ON c.entity_id = m.contact_id '.
    'WHERE '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD .' = "%s" '.
    '  AND ('.
         CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' IS NULL'.
    '    OR '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' = ""'.
    '  ) '.
    'UNION SELECT m.uf_id AS uid '.
    'FROM '. CD_SUNLIGHT_CIVICRM_CUSTOM_TABLE .' c '.
    'INNER JOIN civicrm_uf_match m'.
    '  ON c.entity_id = m.contact_id '.
    'WHERE '. CD_SUNLIGHT_CIVICRM_CUSTOM_FIELD_CD_OVERRIDE .' = "%s" ';
  $res = db_query($sql, $cd, $cd);
  db_set_active();
  while ($user = db_fetch_object($res)) {
    if (!empty($user->uid)) {
      $users[] = $user->uid;
    }
  }
  return $users;
}

/**
 * See if Sunlight is responding and our API key is correct.
 *
 * @return TRUE on success, else FALSE.
 */
function _cd_sunlight_connection_test() {
  $test_data = _cd_sunlight_api_lookup('districts.getDistrictsFromZip', array('zip' => '12345'));
  if ($test_data == FALSE || !isset($test_data[0]['state']) || $test_data[0]['state'] != 'NY') {
    return FALSE;
  }
  return TRUE;
}

/**
 * Used when performing bulk actions against sunlight to avoid clobbering the server.
 */
function _cd_sunlight_sleep() {
  usleep(50000); // 50,000 ?s == 0.05 seconds
}

/**
 * Set the CiviCRM geocoder to be (not) used.
 *
 * @param string $status = 'disabled'
 *  'enabled' or 'disabled'
 * @param string $set_database = FALSE
 *  Save the setting to the database as well?
 * @return boolean
 *  FALSE if this site has not been setup for this, else TRUE.
 */
function _cd_sunlight_geocode_set($status = 'disabled', $set_database = FALSE) {

  if (!variable_get('cd_sunlight_geocoding_off', FALSE)) {
    return TRUE;
  }

  // Set the in-memory configuration.
  $config =& CRM_Core_Config::singleton( );
  if ($status == 'enabled' && !empty($config->mapProvider)) {
    $config->geocodeMethod = 'CRM_Utils_Geocode_'. $config->mapProvider;
  }
  else {
    $config->geocodeMethod = NULL;
  }

  // Save the value in the DB.
  if ($set_database) {
    db_set_active('civicrm');
    $config = db_result(db_query('SELECT config_backend FROM civicrm_domain WHERE id = 1'));
    $config = unserialize($config);
    if (isset($config['mapProvider'])) {
      $config['geocodeMethod'] = $config->geocodeMethod;
      $config = serialize($config);
      if (drupal_strlen($config) > 7) {
        db_query('UPDATE civicrm_domain SET config_backend = "%s" WHERE id = 1', $config);
      }
      else {
        watchdog('cd_sunlight', 'The Geocoder for CiviCRM cannot be set.', array(), WATCHDOG_ERROR);
        return FALSE;
      }
    }
    else {
      return FALSE;
    }
    db_set_active();
  }
  return TRUE;
}

/**
 * Encrypts a string.
 */
function _cd_sunlight_crypt_encrypt($text) {
  if (!_cd_sunlight_crypt_enabled() || !defined('CIVICRM_SITE_KEY') || empty($text)) {
    return FALSE;
  }
  $text = trim(base64_encode(mcrypt_encrypt(
    MCRYPT_BLOWFISH, CIVICRM_SITE_KEY, $text, MCRYPT_MODE_ECB, _cd_sunlight_crypt_iv())));
  return $text;
}

/**
 * Decrypts a string.
 */
function _cd_sunlight_crypt_decrypt($text) {
  if (!_cd_sunlight_crypt_enabled() || !defined('CIVICRM_SITE_KEY') || empty($text)) {
    return FALSE;
  }
  $text = trim(mcrypt_decrypt(MCRYPT_BLOWFISH,
    CIVICRM_SITE_KEY, base64_decode($text), MCRYPT_MODE_ECB, _cd_sunlight_crypt_iv()));
  return $text;
}

/**
 * Are we setup to do encryption?
 */
function _cd_sunlight_crypt_enabled() {
  return function_exists('mcrypt_encrypt') && defined('MCRYPT_BLOWFISH') &&
    defined('MCRYPT_MODE_ECB');
}

/**
 * Get our IV.
 */
function _cd_sunlight_crypt_iv() {
  $iv = variable_get('cd_sunlight_crypt_iv', '');
  if (empty($iv)) {
    $iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_ECB);
    // We want to store this in the variables table.  But if we use the mcrypt functions to build
    // the IV we'll get a non-ascii string which will cause errors during serialization.  So we'll
    // build our own IV from the site private key.
    $iv = drupal_substr(drupal_get_private_key(), 0, $iv_size);
    if (drupal_strlen($iv) < $iv_size) {
      str_pad($iv, $iv_size, mt_rand());
    }
    variable_set('cd_sunlight_crypt_iv', $iv);
  }
  return $iv;
}

/**
 * Check to see if there's any legislators in the table.
 *
 * @return boolean
 */
function _cd_sunlight_legislators_exist() {
  return (bool)db_result(db_query_range('SELECT 1 FROM {cd_sunlight_legislators}', 0, 1));
}

/**
 * Depending on the version of CiviCRM in use.  The API will return differently structured arrays.
 * This normalizes things.
 *
 * @see civicrm_contact_get()
 */
function _cd_sunlight_civicrm_contact_get($search_params) {
  civicrm_initialize();
  require_once 'api/v2/Contact.php';
  $contact = civicrm_contact_get($search_params);
  if (civicrm_error($contact)) {
    return $contact;
  }
  if (!isset($contact['contact_id'])) {
    $contact = array_shift($contact);
    if (!isset($contact['contact_id'])) {
      watchdog('cd_sunlight',
        'CiviCRM is doing strange things.  This version of CiviCRM may not be supported.', array(),
        WATCHDOG_ERROR);
    }
  }
  return $contact;
}

/**
 * Get some backtrace info as a string suitable for watchdogging.
 */
function _cd_sunlight_backtrace() {
  $backtrace = debug_backtrace();
  $info = array();
  foreach ($backtrace as $trace) {
    $info[] = "$trace[file]($trace[line]): $trace[function]";
  }
  return var_export($info, TRUE);
}
