<?php
// $Id$

/**
 * @file
 * Simpletests for the cd_sunlight module.
 */

class cdSunlightWebTestCase extends DrupalWebTestCase {

  /**
   * Implementation of getInfo() for information
   */
  public static function getInfo() {
    return array(
      'name' => t('CiviCRM Sunlight Congressional Districts tests'),
      'desc' => t('Test queuing, dequeing, and data fetching.'),
      'group' => 'CiviCRM Sunlight Congressional Districts',
    );
  }

  /**
   * SimpleTest core method: code run before each and every test method.
   */
  function setUp() {

    // Install our modules.
    $args = func_get_args();
    $modules = array_merge(array('cd_sunlight', 'civicrm', 'simpletest', 'devel'), $args);
    call_user_func_array(array('parent', 'setUp'), $modules);

    // Turn CiviCRM geocoding off so that this doesn't fire when we process the queue.
    variable_set('cd_sunlight_geocoding_off', TRUE);
    _cd_sunlight_geocode_set();
    
    // Copy the other required variables.  Don't prefix so that we opperate on the original table.
    $cd_sunlight_api_key = unserialize(db_result(db_query(
      'SELECT value FROM variable WHERE name = "cd_sunlight_api_key"')));
    $this->verbose('API KEY:'. $cd_sunlight_api_key);
    variable_set('cd_sunlight_api_key', $cd_sunlight_api_key);
    $cd_sunlight_civicrm_cd = unserialize(db_result(db_query(
      'SELECT value FROM variable WHERE name = "cd_sunlight_civicrm_cd"')));
    variable_set('cd_sunlight_civicrm_cd', $cd_sunlight_civicrm_cd);
    $cd_sunlight_civicrm_cd_override = unserialize(db_result(db_query(
      'SELECT value FROM variable WHERE name = "cd_sunlight_civicrm_cd_override"')));
    variable_set('cd_sunlight_civicrm_cd_override', $cd_sunlight_civicrm_cd_override);

  }

  /**
   * SimpleTest core method: code run after each and every test method.
   */
  function tearDown() {
    variable_del('cd_sunlight_geocoding_off');
    variable_del('cd_sunlight_api_key');
    variable_del('cd_sunlight_civicrm_cd');
    variable_del('cd_sunlight_civicrm_cd_override');

    // Finally...
    parent::tearDown();
  }

  /**
   * Create new contact, it should be queued for lookup.
   * Dequeue and test.
   * Edit the contact, it should be queued for lookup.
   * Process the queue, it should have the correct CD retrieved.
   */
  function testCDSunlight() {

    // Test that the module is setup.
    $requirements = cd_sunlight_requirements('runtime');
    $this->verbose(var_export($requirements, TRUE));
    foreach ($requirements as $requirement) {
      if ($requirement['severity'] == REQUIREMENT_ERROR) {
        $this->fail("The module is not setup properly.");
        return;
      }
    }

    // Test that the queue is empty.
    $count = $requirements['cd_sunlight_count']['count'];
    if ($count != 0) {
      $this->fail("There are $count contacts in the cron queue.  ".
        "The queue needs to be empty to run these simpletests.");
      return;
    }

    // Setup CiviCRM
    if (!function_exists('civicrm_initialize') || !civicrm_initialize()) {
      $this->fail('CiviCRM does not appear to be setup correctly.');
      return;
    }
    $include_result = include('api/v2/Contact.php');
    if ($include_result === FALSE) {
      $this->fail('CiviCRM does not appear to be setup correctly.');
      return;
    }

    // Create the contact.
    $contact_new = array(
      'first_name' => 'Simpletest test',
      'last_name' => 'Simpletest test',
      'email' => 'simpletest@example.org',
      'contact_type' => 'Individual',
      'dupe_check' => FALSE,
    );
    $contact = civicrm_contact_add($contact_new);
    if (civicrm_error($contact)) {
      $this->fail('A CiviCRM contact could not be created.  This might happen if you '.
        'have non-standard required fields or other restrictions on contacts.'.
        var_export($contact_new, TRUE) . var_export($contact, TRUE));
      return;
    }

    // Create the location.
    // We are making an overly complex array here to be compatible with several versions of the
    // CiviCRM API.
    // This is really stoopid to begin with.  We should just be able to manipulate primary locations
    // via the contact api. 
    $location_new = array(
      'contact_id' => $contact['contact_id'],
      'version'    => '3.0',
      'address' => array(
        '1' => array(
          'location_type' => 'Home',
          'location_type_id' => 1,
          'is_primary' => TRUE,
          'postal_code' => '00501',
          'country_id' => CD_SUNLIGHT_CIVICRM_US_COUNTRY_ID,
        ),
      ),
      'location_type' => 'Home',
      'location_type_id' => 1,
      'is_primary' => TRUE,
      'postal_code' => '00501',
      'country_id' => CD_SUNLIGHT_CIVICRM_US_COUNTRY_ID,
    );
    require_once 'api/v2/Location.php';
    $location =& civicrm_location_add($location_new);
    if (civicrm_error($location)) {
      $this->fail('A location could not be created for the contact.  This might happen if you '.
        'have non-standard required fields or other restrictions on contacts.'.
        var_export($location_new, TRUE) . var_export($location, TRUE));
      return;
    }

    // Test that it was created correctly.
    $contact_search = array(
      'contact_id' => $contact['contact_id'],
      'return.'. CD_SUNLIGHT_CIVICRM_CD => TRUE,
      'return.postal_code' => TRUE,
      'return.country' => TRUE,
      'return.contact_type' => TRUE,
    );
    $contact = civicrm_contact_get($contact_search);
    $this->assertEqual($contact['postal_code'], '00501', 'A CiviCRM contact simpletest@example.org was created.');
    $this->verbose(
      '$new_contact: '. var_export($contact_new, TRUE) .
      '$contact: '. var_export($contact, TRUE) .
      '$location_new: '. var_export($location_new, TRUE) .
      '$location: '. var_export($location, TRUE));

    // Show warning because the CiviCRM API un-hacked will not work.
    $this->fail('The remaining assertions will probably fail due to issues with the CiviCRM '.
      'Location API.  Hopefully these will be fixed by 3.1');

    // Test that it was enqueued.
    $this->assertTrue($this->_checkQueue($contact['contact_id']), 'Contact enqueued when created.');

    // Process and test.
    variable_set('cd_sunlight_geocoding_off', FALSE);
    _cd_sunlight_process_queue();
    variable_set('cd_sunlight_geocoding_off', TRUE);
    $this->assertFalse($this->_checkQueue($contact['contact_id']), 'Contact dequeued when queue processed.');
    $contact = civicrm_contact_get($contact_search);
    $this->assertEqual($contact[CD_SUNLIGHT_CIVICRM_CD], 'NY1', 'Contact CD is '. $contact[CD_SUNLIGHT_CIVICRM_CD]);
    $this->verbose(var_export($contact_search, TRUE) . var_export($contact, TRUE));

    // Edit the contact.
    $location_update = array(
      'contact_id' => $contact['contact_id'],
      'location_type' => 'Home',
      'location_type_id' => 1,
      'is_primary' => TRUE,
      'postal_code' => '12345',
      'version'    => '3.0',
      'address' => array(
        1 => array(
          'location_type' => 'Home',
          'location_type_id' => 1,
          'is_primary' => TRUE,
          'postal_code' => '12345',
        ),
      ),
    );
    $location = civicrm_location_update($location_update);
    if (civicrm_error($location)) {
      $this->fail('The CiviCRM contact could not be edited: '.
        var_export($location_update, TRUE) . var_export($location, TRUE));
      return;
    }

    // We should have the new postal code.
    $contact = civicrm_contact_get($contact_search);
    $this->assertEqual($contact['postal_code'], '12345', 'CiviCRM contact simpletest@example.org was edited.');
    $this->verbose(
      '$contact_search: '. var_export($contact_search, TRUE) .
      '$contact: '. var_export($contact, TRUE) .
      '$location_update: '. var_export($location_update, TRUE) .
      '$location: '. var_export($location, TRUE));

    // Editing the postal code should re-enqueue the contact.
    $this->assertTrue($this->_checkQueue($contact['contact_id']), 'Contact enqueued when edited');

    // Process the queue, our contact should be processed.
    variable_set('cd_sunlight_geocoding_off', FALSE);
    _cd_sunlight_process_queue();
    variable_set('cd_sunlight_geocoding_off', TRUE);
    $this->assertFalse($this->_checkQueue($contact['contact_id']), 'Contact dequeued when queue processed.');
    $contact = civicrm_contact_get($contact_search);
    $this->assertEqual($contact[CD_SUNLIGHT_CIVICRM_CD], 'NY21', 'Contact CD is '. $contact[CD_SUNLIGHT_CIVICRM_CD]);
    $this->verbose(
      '$contact_search: '. var_export($contact_search, TRUE) .
      '$contact: '. var_export($contact, TRUE));

    // Cleanup. Delete the contact.
    $result = civicrm_contact_delete($contact);
    if ($result['is_error']) {
      $this->fail("The test CiviCRM contact 'Simpletest test' could not be deleted.");
    }

  }

  /**
   * Is the contact ID in the cron queue?
   *
   * @param int $contact_id
   */
  function _checkQueue($contact_id) {
    return db_result(db_query('SELECT 1 FROM {cd_sunlight_cron} WHERE contact_id = %d', $contact_id));
  }

}